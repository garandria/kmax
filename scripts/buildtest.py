#!/usr/bin/env python

import argparse
import os
import sys
import subprocess
import csv
import tempfile
import shutil
import datetime
from time import perf_counter

def __get_time_refpoint():
  return perf_counter()

def info(msg, ending="\n"):
  sys.stderr.write("INFO: %s%s" % (msg, ending))

def warning(msg, ending="\n"):
  sys.stderr.write("WARNING: %s%s" % (msg, ending))

def error(msg, ending="\n"):
  sys.stderr.write("ERROR: %s%s" % (msg, ending))


def build_testcase(cfgfilepath: str, outfile, errfile, arch_name: str, makescript: str, linux_ksrc: str, timeout="10m"):
  """
  Test a Kconfig config file against the build system and return the exit code
  of the makescript.

  Arguments:
  cfgfilepath -- Path to the Kconfig config file to use for building.
  outfile -- File object to write the build process' out.
  errfile -- File object to write the build process' err.
  arch_name -- Name of the architecture.
  makescript -- Make script, e.g., `make.cross`.
  linux_ksrc -- Path to the Linux kernel source.
  timeout -- Timeout limit for the build process.
  """
  assert os.path.isfile(cfgfilepath)

  # use a copy so the original won't change
  buildcopy_path = "buildtestcopy_" + os.path.basename(cfgfilepath)
  buildcopy = shutil.copyfile(cfgfilepath, buildcopy_path)
  assert os.path.isfile(buildcopy)

  olddef_cmd = "{makescript} KCONFIG_CONFIG={kconfig_file} ARCH={arch_name} olddefconfig".format(makescript=makescript, kconfig_file=buildcopy, arch_name=arch_name)
  clean_cmd = "{makescript} ARCH={arch_name} clean".format(makescript=makescript, arch_name=arch_name)
  build_cmd = "timeout {timeout} bash -c '{makescript} ARCH={arch_name}'".format(makescript=makescript, arch_name=arch_name, timeout=timeout)

  subprocess.Popen(olddef_cmd, shell=True, stdin=subprocess.DEVNULL, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, cwd=linux_ksrc).communicate()
  subprocess.Popen(clean_cmd, shell=True, stdin=subprocess.DEVNULL, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, cwd=linux_ksrc).communicate()
  build_popen = subprocess.Popen(build_cmd, shell=True, stdin=subprocess.DEVNULL, stdout=outfile, stderr=errfile, cwd=linux_ksrc)
  build_popen.communicate()
  ret_code = build_popen.returncode
  
  # clean temporary config files
  os.remove(buildcopy)
  old_copy = buildcopy+".old"# should be automatically generated by make
  if os.path.exists(old_copy): os.remove(old_copy)
  
  return ret_code
    
if __name__ == '__main__':
  t_start_main = __get_time_refpoint()

  argparser = argparse.ArgumentParser()
  
  argparser.add_argument('-k',
                         '--kismet-summary-csv',
                        type=str,
                        required=True,
                        help="""Path to a summary CSV file in kismet's format.  This file will be replaced with an extended version including the build test analysis info.""")
  argparser.add_argument('--linux-ksrc',
                        type=str,
                        default="./",
                        help="""Path to the Linux kernel source directory.  Defaults to \"./\"""")
  argparser.add_argument('--make-path',
                        type=str,
                        required=True,
                        help="""Path to the make script which will be used to build.  \"make.cross\" may be used to cross compile.""")
  argparser.add_argument('-S',
                         '--make-args',
                         type=str,
                         default="",
                         help="""Additional command line arguments to be passed to the make script.""")

  args = argparser.parse_args()
  csv_path = os.path.realpath(os.path.expanduser(args.kismet_summary_csv))
  linux_ksrc = os.path.realpath(os.path.expanduser(args.linux_ksrc))
  make_path = args.make_path
  make_args = args.make_args

  # check args
  assert os.path.isfile(csv_path)
  assert os.path.exists(linux_ksrc)
  popen = subprocess.Popen("%s --version" % make_path, shell=True, stdin=subprocess.DEVNULL, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
  popen.communicate()
  assert popen.returncode == 0

  info("The script will build-test the verified unmet dependency testcases.")
  info("Kismet's summary csv at '%s' will be read and extended with the build-test results." % csv_path)
  info("For those with build errors, the stdout and stderr of the build process will be saved and populated in the extended summary.")
  info("All times reported are measured using Python's time.perf_counter() utility.")
  
  # First detect how many cases will be build-tested to track progress
  info("Reading the summary file at '%s'.." % csv_path)
  all_count = 0
  verified_alarms_count = 0
  with open(csv_path, 'r') as in_file:
    csv_reader = csv.reader(in_file)
    for i, row in enumerate(csv_reader):
      if i == 0:
        verified_index = row.index("verified")
      else:
        verified_alarms_count += row[verified_index] == "True"
        all_count += 1
  info("Summary file was read. %d constructs with verified alarms out of %d constructs from the summary will be build-tested." % (verified_alarms_count, all_count))

  info("Starting the build-test: only those constructs with verified alarms will be reported as log.")
  tested = 0
  build_errors_found = 0
  def dump_progress():
    t_spent_until = __get_time_refpoint() - t_start_main
    progress_str = "%d/%d testcases have been build-tested in %.2fsec, %d have been found to cause build errors." % (tested, verified_alarms_count, t_spent_until, build_errors_found)
    info("Build-test progress: %s." % progress_str, ending="\r")
  dump_progress()
  csv_path_output = csv_path+"_tmp"
  with open(csv_path, 'r') as in_file, open(csv_path_output, 'w') as out_file:
    csv_reader = csv.reader(in_file)
    csv_writer = csv.writer(out_file)
    for i, row in enumerate(csv_reader):

      if i == 0:
        # get the index info
        selectee_index = row.index("selectee")
        selector_index = row.index("selector")
        arch_index = row.index("arch")
        analysis_result_index = row.index("analysis_result")
        verified_index = row.index("verified")
        testcase_index = row.index("testcase")

        # extend the header and write
        row.append("is_build_error")
        row.append("build_out")
        row.append("build_err")
        csv_writer.writerow(row)
        continue
      
      selectee = row[selectee_index]
      selector = row[selector_index]
      arch_name = row[arch_index]
      is_alarm = row[analysis_result_index] == "UNMET_ALARM"
      is_verified = row[verified_index] == "True"
      testcase_path = row[testcase_index]

      if not is_verified:
        # extend the row and write
        row.extend([ "N/A", "N/A", "N/A" ])
        csv_writer.writerow(row)
        continue
      
      # a verified udd: do build test
      #info("Doing build-test for (%s, %s) pair using testcase at %s." % (selectee, selector, testcase_path))
      buildout_path = os.path.splitext(testcase_path)[0]+ ".build_out"
      builderr_path = os.path.splitext(testcase_path)[0]+ ".build_err"
      with open(buildout_path, "w") as buildout, open(builderr_path, "w") as builderr:
        ret_code = build_testcase(cfgfilepath=testcase_path, outfile=buildout, errfile=builderr, arch_name=arch_name, makescript=make_path, linux_ksrc=linux_ksrc)

      is_build_error = ret_code != 0
      #info("Done build-test for (%s, %s): build error: %s." % (selectee, selector, is_build_error))
      tested += 1
      build_errors_found += is_build_error
      dump_progress()
      if is_build_error:
        row.extend([ "True", buildout_path, builderr_path] )
      else:
        row.extend([ "False", "N/A", "N/A" ] )
        os.remove(buildout_path)
        os.remove(builderr_path)
      
      csv_writer.writerow(row)
  info("") # complete progress

  info("Finished the build test for all verified unmet dependency alarms.")
  t_spent_all = __get_time_refpoint() - t_start_main
  info("%d constructs with verified unmet dependency alarms were build-tested in %.2fsec. %d resulted in build errors." % (all_count, t_spent_all, build_errors_found))
  info("Replacing the summary file with build-test extended summary..")
  shutil.copyfile(csv_path_output, csv_path)
  os.remove(csv_path_output)
  info("Summary file at '%s' was updated." % csv_path)