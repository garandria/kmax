#!/usr/bin/env python3
import pdb
from pathlib import Path
import argparse
import z3
import pickle
import time

import settings
import vcommon as CM

DBG = pdb.set_trace

mlog = CM.getLogger(__name__, settings.logger_level)


class Z3:
    zTrue = z3.BoolVal(True)
    zFalse = z3.BoolVal(False)
    CONNECTIVE_OPS = [z3.Z3_OP_NOT, z3. Z3_OP_AND,
                      z3. Z3_OP_OR, z3.Z3_OP_IMPLIES,
                      z3.Z3_OP_IFF, z3.Z3_OP_ITE, z3.Z3_OP_XOR]

    @classmethod
    def simplify(cls, f):
        assert z3.is_expr(f), f
        simpl = z3.Tactic('ctx-solver-simplify')
        simpl = z3.TryFor(simpl, settings.SOLVER_TIMEOUT)
        try:
            f = simpl(f).as_expr()
        except z3.Z3Exception:
            pass
        return f

    @classmethod
    def is_connective_op(cls, e):
        return e.decl().kind() in cls.CONNECTIVE_OPS

    @classmethod
    def is_var(cls, e):
        return z3.is_const(e) and e.decl().kind() == z3.Z3_OP_UNINTERPRETED

    @classmethod
    def is_purely(cls, e, op):
        if cls.is_var(e):
            return True
        elif e.decl().kind() == op:
            return all(cls.is_purely(c, op) for c in e.children())
        elif e.decl().kind() == z3.Z3_OP_NOT:
            return len(e.children()) == 1 and cls.is_var(e.children()[0])
        else:
            return False

    @classmethod
    def is_purely_conj(cls, e):
        return cls.is_purely(e, z3.Z3_OP_AND)

    @classmethod
    def is_purely_disj(cls, e):
        return cls.is_purely(e, z3.Z3_OP_OR)

    @classmethod
    def traverse(cls, expr, f):
        f(expr)
        for c in expr.children():
            cls.traverse(c, f)

    @classmethod
    def collect(cls, e, check):
        def f(e, results):
            if check(e):
                results.append(e)

        results = []

        def f_(e_):
            return f(e_, results)

        cls.traverse(e, f_)
        return results


class ConstraintInfo:
    TRUE = "true"
    CONJ = "conj"
    DISJ = "disj"
    MIXED = "mix"

    def __init__(self):
        self.typ = None
        self.files = set()
        self.config_vars = set()


class DB:
    def __init__(self, filename):
        self.filename = filename
        self.files_d = {}  # file -> constraint
        self.constraints_d = {}  # constraint -> {files}

    @classmethod
    def load(cls, kmax_file):
        assert kmax_file.is_dir() or kmax_file.is_file(), kmax_file

        if kmax_file.is_dir():
            kmax_file = kmax_file / 'kmax'

        if not kmax_file.is_file():
            mlog.error("{} does not exist!".format(kmax_file))
            exit(1)

        with open(kmax_file, 'rb') as fp:
            kmax = pickle.load(fp)
            return kmax

    @classmethod
    def create_from_file(cls, kmax_file):
        d = cls.load(kmax_file)

        db = cls(kmax_file)
        for compile_file in d:
            constraint = d[compile_file]
            constraint = z3.parse_smt2_string(constraint)
            assert isinstance(constraint, z3.z3.AstVector), constraint
            assert len(constraint) <= 1, constraint
            if len(constraint) == 0:
                constraint = None
            else:
                assert len(constraint) == 1, constraint
                constraint = Z3.simplify(constraint[0])

            assert (constraint is None or
                    (z3.is_expr(constraint) and not bool(constraint == Z3.zFalse))), constraint
            if bool(constraint == Z3.zTrue):
                constraint = None

            db.files_d[compile_file] = constraint
            if constraint not in db.constraints_d:
                c_info = ConstraintInfo()
                c_info.config_vars = (set() if constraint is None else
                                      set(Z3.collect(constraint, Z3.is_var)))

                # determine constraint type
                if constraint is None:
                    c_info.typ = ConstraintInfo.TRUE
                elif Z3.is_purely_conj(constraint):
                    c_info.typ = ConstraintInfo.CONJ
                elif Z3.is_purely_disj(constraint):
                    c_info.typ = ConstraintInfo.DISJ
                else:
                    c_info.typ = ConstraintInfo.MIXED

                db.constraints_d[constraint] = c_info

            db.constraints_d[constraint].files.add(compile_file)

        return db


class Analysis:
    def __init__(self, db):
        assert isinstance(db, DB), db
        self.db = db

    def doit(self):
        mlog.info("kmax file:'{}'".format(self.db.filename))
        mlog.info("compile files: {}".format(len(self.db.files_d)))
        mlog.info("# of files with no constraint: {}".format(
            len(self.db.constraints_d[None].files)))

        self.compute_config_vars()
        mlog.info("config vars: {}".format(len(self.config_vars)))

        mlog.info("constraints: {}".format(len(self.db.constraints_d)))
        self.compute_typs_lens()
        mlog.info("constraint typs: {}".format(', '.join("{} {}".format(
            typ, self.typs_d[typ]) for typ in sorted(self.typs_d))))
        ss = (', '.join("{} {}".format(
            typ, self.largest_lens_d[typ]) for typ in sorted(self.largest_lens_d)))
        mlog.info("constraint lens: avg {}, {}".format(self.avg_len, ss))

        self.get_len_cov(maxk=10)
        ss = (', '.join("{} {} {}".format(
            k, self.lens_d[k], len(self.lens_covs_d[k])) for k in sorted(self.lens_covs_d)))
        mlog.info("constraint (len, count, cov): {}".format(ss))
        # TODO:  output/mlog.debug the names of the files

    def compute_config_vars(self):
        config_vars = set()
        for c_info in self.db.constraints_d.values():
            config_vars = config_vars.union(c_info.config_vars)

        self.config_vars = config_vars

    def compute_typs_lens(self):
        typs_d = {}
        largest_lens_d = {}

        total_len = 0
        for c_info in self.db.constraints_d.values():
            len_ = len(c_info.config_vars)
            total_len += len_

            if c_info.typ not in typs_d:
                typs_d[c_info.typ] = 0
            typs_d[c_info.typ] += 1

            if c_info.typ not in largest_lens_d:
                largest_lens_d[c_info.typ] = len_
            else:
                if len_ > largest_lens_d[c_info.typ]:
                    largest_lens_d[c_info.typ] = len_

        self.avg_len = total_len / len(self.db.constraints_d)
        self.typs_d = typs_d
        self.largest_lens_d = largest_lens_d

    def get_influential_configs(self):
        influential_d = {}
        for constraint in self.db.constraints_d:
            if constraint is None:  # no constraint, i.e., True
                continue  # no influential
            for cv in self.db.constraints_d[constraint].config_vars:
                if cv not in influential_d:
                    influential_d[cv] = set()
                for f in self.db.constraints_d[constraint].files:
                    influential_d[cv].add(f)

        influential_vars = sorted(
            influential_d.keys(), key=lambda x: len(influential_d[x]),
            reverse=True)

        print('\n'.join("{}: {}".format(
            v, len(influential_d[v])) for v in influential_vars[:10]))

    def get_len_cov(self, maxk=None):
        """
        Return a mapping from condition len to # of files covered by
        conditions of that length
        """
        lens_d = {}   # how many constraints of this size
        lens_covs_d = {}  # how much cov of constraints of this size
        for constraint, c_info in self.db.constraints_d.items():
            k = len(c_info.config_vars)

            if maxk and k >= maxk:
                k = maxk
            if k == 0:
                print(constraint, c_info.typ)
            if k not in lens_covs_d:
                lens_d[k] = 0
                lens_covs_d[k] = set()
            lens_d[k] += 1
            lens_covs_d[k] = lens_covs_d[k].union(c_info.files)

        self.lens_d = lens_d
        self.lens_covs_d = lens_covs_d


if __name__ == '__main__':
    argparser = argparse.ArgumentParser("KAnalysis")

    # 0 Error #1 Warn #2 Info #3 Debug #4 Detail
    ag = argparser.add_argument

    ag("inp", help="path to the directory or file containing kmax formula")

    ag("--log_level", "-log_level",
       type=int,
       choices=range(5),
       default=2,
       help="set logger info")

    # ag('--formulas',
    #    type=str,
    #    default=".kmax/",
    #    help="""Path to the formulas which contain one kmax file for all compilation units and one directory for each architecture containing kclause files.  Defaults to \".kmax/\"""")

    # ag('--kmax-formulas',
    #    type=str,
    #    default=None,
    #    help="""The file containing the Kbuild constraints as a pickled dictionary from compilation unit to formula.  Defaults to \"kmax\" in the --formulas directory.""")
    ag("--pathprefix",
       type=str,
       help="retrieve kmax formulas for this path prefix")
    args = argparser.parse_args()

    if 0 <= args.log_level <= 4 and args.log_level != settings.logger_level:
        settings.logger_level = args.log_level

    kmax_file = Path(args.inp)

    kmax_db = DB.create_from_file(kmax_file)
    analysis = Analysis(kmax_db)
    analysis.doit()

    # analysis.get_stats()
    # analysis.get_influential_configs()
    # formulas = {unit: get_conditions(
    #     kmax_formulas, unit) for unit in kmax_formulas}
    # path_prefix = args.pathprefix
    # print(path_prefix)
    # filtered_formulas = {}
    # print(formulas)  # remove to avoid printing the whole map


# def get_conditions(kmax_formulas, kbuild_path):
#     DBG()
#     if kbuild_path in kmax_formulas:
#         conditions = []
#         # add the condition for the compilation unit and each of its parent directories
#         unit_constraint = z3.parse_smt2_string(kmax_formulas[kbuild_path])
#         conditions.extend(unit_constraint)
#         mlog.debug("{} => {}".format(kbuild_path, unit_constraint))

#         if '/' in kbuild_path:
#             subpath, basename = kbuild_path.rsplit('/', 1)
#             elems = subpath.rsplit('/')
#             for i in range(0, len(elems)):
#                 subarray = elems[0:(len(elems) - i)]
#                 subsubpath = '/'.join(subarray) + "/"
#                 if subsubpath in kmax_formulas.keys():
#                     subsubpath_constraint = z3.parse_smt2_string(
#                         kmax_formulas[subsubpath])
#                     conditions.extend(subsubpath_constraint)
#                     mlog.debug("%s\n%s\n" %
#                                (subsubpath, subsubpath_constraint))
#                 else:
#                     mlog.info("%s has no kmax formula, assuming it is unconstrained." % (
#                         subsubpath))
#         return conditions
#     else:
#         return None
