#!/usr/bin/env python3
import pdb
from pathlib import Path
import argparse
import z3
import pickle
import time

import settings
import vcommon as CM

DBG = pdb.set_trace

mlog = CM.getLogger(__name__, settings.logger_level)


class Z3:

    CONNECTIVE_OPS = [z3.Z3_OP_NOT, z3. Z3_OP_AND,
                      z3. Z3_OP_OR, z3.Z3_OP_IMPLIES,
                      z3.Z3_OP_IFF, z3.Z3_OP_ITE, z3.Z3_OP_XOR]

    @classmethod
    def simplify(cls, f):
        assert z3.is_expr(f), f
        simpl = z3.Tactic('ctx-solver-simplify')
        simpl = z3.TryFor(simpl, settings.SOLVER_TIMEOUT)
        try:
            f = simpl(f).as_expr()
        except z3.Z3Exception:
            pass
        return f

    @classmethod
    def is_connective_op(cls, e):
        return e.decl().kind() in cls.CONNECTIVE_OPS

    @classmethod
    def is_var(cls, e):
        return z3.is_const(e) and e.decl().kind() == z3.Z3_OP_UNINTERPRETED

    @classmethod
    def is_purely(cls, e, op):
        if cls.is_var(e):
            return True
        elif e.decl().kind() == op:
            return all(cls.is_purely(c, op) for c in e.children())
        elif e.decl().kind() == z3.Z3_OP_NOT:
            return len(e.children()) == 1 and cls.is_var(e.children()[0])
        else:
            return False

    @classmethod
    def is_purely_conj(cls, e):
        return cls.is_purely(e, z3.Z3_OP_AND)

    @classmethod
    def is_purely_disj(cls, e):
        return cls.is_purely(e, z3.Z3_OP_OR)

    @classmethod
    def traverse(cls, expr, f):
        f(expr)
        for c in expr.children():
            cls.traverse(c, f)

    @classmethod
    def collect(cls, e, check):
        def f(e, results):
            if check(e):
                results.append(e)

        results = []

        def f_(e_):
            return f(e_, results)

        cls.traverse(e, f_)
        return results


class ConstraintInfo:
    TRUE = "no constraint"
    CONJ = "conj"
    DISJ = "disj"
    MIXED = "mix"

    def __init__(self):
        self.typ = None
        self.files = set()
        self.config_vars = set()


class DB:
    def __init__(self):
        self.files_d = {}  # file -> constraint
        self.constraints_d = {}  # constraint -> {files}

    @classmethod
    def load(cls, kmax_file):
        assert kmax_file.is_dir() or kmax_file.is_file(), kmax_file

        if kmax_file.is_dir():
            kmax_file = kmax_file / 'kmax'

        if not kmax_file.is_file():
            mlog.error("{} does not exist!".format(kmax_file))
            exit(1)

        with open(kmax_file, 'rb') as fp:
            kmax = pickle.load(fp)
            return kmax

    @classmethod
    def create_from_file(cls, kmax_file):
        d = cls.load(kmax_file)

        db = cls()
        for compile_file in d:
            constraint = d[compile_file]
            constraint = z3.parse_smt2_string(constraint)
            assert isinstance(constraint, z3.z3.AstVector), constraint
            assert len(constraint) <= 1, constraint
            if len(constraint) == 0:
                constraint = None
            else:
                assert len(constraint) == 1, constraint
                constraint = Z3.simplify(constraint[0])

            db.files_d[compile_file] = constraint
            if constraint not in db.constraints_d:
                db.constraints_d[constraint] = ConstraintInfo()
            db.constraints_d[constraint].files.add(compile_file)
        return db


class Analysis:
    def __init__(self, db):
        assert isinstance(db, DB), db
        self.db = db
        self.compute()

    def compute(self):
        for constraint, c_info in db.constraints_d.items():

            # determine config variables in constraint

            c_info.config_vars = (set() if constraint is None else
                                  set(Z3.collect(constraint, Z3.is_var)))

            # determine constraint type
            if constraint is None:
                c_info.typ = ConstraintInfo.TRUE
            elif Z3.is_purely_conj(constraint):
                c_info.typ = ConstraintInfo.CONJ
            elif Z3.is_purely_disj(constraint):
                c_info.typ = ConstraintInfo.DISJ
            else:
                c_info.type = ConstraintInfo.MIXED

    def get_influential(self):
        st = time.time()
        influential_d = {}
        for constraint in self.db.constraints_d:
            if constraint is None:  # no constraint, i.e., True
                continue  # no influential
            for cv in self.db.constraints_d[constraint].config_vars:
                if cv not in influential_d:
                    influential_d[cv] = set()
                for f in self.db.constraints_d[constraint].files:
                    influential_d[cv].add(f)

        print('hi 1', time.time() - st)
        influential_vars = sorted(
            influential_d.keys(), key=lambda x: len(influential_d[x]),
            reverse=True)

        print('\n'.join("{}: {}".format(
            v, len(influential_d[v])) for v in influential_vars[:10]))

        # for tv in tvs:
        #     files = set()

        #
        #         else:
        #             myconstraint = z3.And(cv == tv, constraint)
        #             solver.add(myconstraint)
        #             stat = solver.check()
        #             solver.reset()
        #             # print(myconstraint)
        #             if stat == z3.sat:
        #                 for f in self.db.constraints_d[constraint].files:
        #                     files.add(f)
        #             else:
        #                 print('UNSAT', myconstraint)

        # assert tv not in influential_d[cv]
        # influential_d[cv][tv] = files

    def get_stats(self):
        config_vars = set()
        n_true = 0
        n_conj = 0
        n_disj = 0
        n_mixed = 0

        longest_conj = 0
        longest_disj = 0
        longest_mixed = 0
        longest_total = 0
        total_len = 0
        for c_info in db.constraints_d.values():
            for cv in c_info.config_vars:
                config_vars.add(cv)

            len_ = len(c_info.config_vars)
            total_len += len_
            if len_ > longest_total:
                longest_total = len_

            if c_info.typ == ConstraintInfo.TRUE:
                n_true += 1
            elif c_info.typ == ConstraintInfo.CONJ:
                n_conj += 1
                if len_ > longest_conj:
                    longest_conj = len_
            elif c_info.typ == ConstraintInfo.DISJ:
                n_disj += 1
                if len_ > longest_disj:
                    longest_disj = len_
            else:
                n_mixed += 1
                if len_ > longest_mixed:
                    longest_mixed = len_

        avg_len = total_len / len(db.constraints_d)

        mlog.info("{} config vars, {} constraints, {} compile units".format(
            len(config_vars), len(db.constraints_d), len(db.files_d)))
        mlog.info("true {}, conj {}, disj {}, mixed {}".format(
            n_true, n_conj, n_disj, n_mixed))
        mlog.info("cond lens: top {} (conj {}, disj {}, mixed {}), avg {}".format(
            longest_total, longest_conj, longest_disj, longest_mixed, avg_len))
        mlog.info("# of files with no constraint: {}".format(
            len(db.constraints_d[None].files)))
        self.config_vars = config_vars


if __name__ == '__main__':
    argparser = argparse.ArgumentParser("KAnalysis")

    # 0 Error #1 Warn #2 Info #3 Debug #4 Detail
    ag = argparser.add_argument

    ag("inp", help="path to the directory or file containing kmax formula")

    ag("--log_level", "-log_level",
       type=int,
       choices=range(5),
       default=2,
       help="set logger info")

    # ag('--formulas',
    #    type=str,
    #    default=".kmax/",
    #    help="""Path to the formulas which contain one kmax file for all compilation units and one directory for each architecture containing kclause files.  Defaults to \".kmax/\"""")

    # ag('--kmax-formulas',
    #    type=str,
    #    default=None,
    #    help="""The file containing the Kbuild constraints as a pickled dictionary from compilation unit to formula.  Defaults to \"kmax\" in the --formulas directory.""")
    ag("--pathprefix",
       type=str,
       help="retrieve kmax formulas for this path prefix")
    args = argparser.parse_args()

    if 0 <= args.log_level <= 4 and args.log_level != settings.logger_level:
        settings.logger_level = args.log_level

    kmax_file = Path(args.inp)

    db = DB.create_from_file(kmax_file)
    analysis = Analysis(db)
    analysis.get_stats()
    analysis.get_influential()
    # formulas = {unit: get_conditions(
    #     kmax_formulas, unit) for unit in kmax_formulas}
    # path_prefix = args.pathprefix
    # print(path_prefix)
    # filtered_formulas = {}
    # print(formulas)  # remove to avoid printing the whole map


# def get_conditions(kmax_formulas, kbuild_path):
#     DBG()
#     if kbuild_path in kmax_formulas:
#         conditions = []
#         # add the condition for the compilation unit and each of its parent directories
#         unit_constraint = z3.parse_smt2_string(kmax_formulas[kbuild_path])
#         conditions.extend(unit_constraint)
#         mlog.debug("{} => {}".format(kbuild_path, unit_constraint))

#         if '/' in kbuild_path:
#             subpath, basename = kbuild_path.rsplit('/', 1)
#             elems = subpath.rsplit('/')
#             for i in range(0, len(elems)):
#                 subarray = elems[0:(len(elems) - i)]
#                 subsubpath = '/'.join(subarray) + "/"
#                 if subsubpath in kmax_formulas.keys():
#                     subsubpath_constraint = z3.parse_smt2_string(
#                         kmax_formulas[subsubpath])
#                     conditions.extend(subsubpath_constraint)
#                     mlog.debug("%s\n%s\n" %
#                                (subsubpath, subsubpath_constraint))
#                 else:
#                     mlog.info("%s has no kmax formula, assuming it is unconstrained." % (
#                         subsubpath))
#         return conditions
#     else:
#         return None
