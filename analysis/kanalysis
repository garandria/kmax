#!/usr/bin/env python3
import pdb
from pathlib import Path
import argparse
import z3
import pickle


import settings
import vcommon as CM

DBG = pdb.set_trace

mlog = CM.getLogger(__name__, settings.logger_level)


class Z3:

    CONNECTIVE_OPS = [z3.Z3_OP_NOT, z3. Z3_OP_AND,
                      z3. Z3_OP_OR, z3.Z3_OP_IMPLIES,
                      z3.Z3_OP_IFF, z3.Z3_OP_ITE, z3.Z3_OP_XOR]

    @classmethod
    def simplify(cls, f):
        assert z3.is_expr(f), f
        simpl = z3.Tactic('ctx-solver-simplify')
        simpl = z3.TryFor(simpl, settings.SOLVER_TIMEOUT)
        try:
            f = simpl(f).as_expr()
        except z3.Z3Exception:
            pass
        return f

    @classmethod
    def traverse(cls, expr, f):
        f(expr)
        for c in expr.children():
            cls.traverse(c, f)

    @classmethod
    def collect(cls, expr, f):
        assert z3.is_expr(expr), expr

        results = []

        def f_(e):
            return f(e, results)

        cls.traverse(expr, f_)

        return results

    @classmethod
    def collect_connective_ops(cls, e):
        def f(e, results):
            if e.decl().kind() in cls.CONNECTIVE_OPS:
                results.append(e.decl())

        return set(cls.collect(e, f))

    @classmethod
    def collect_vars(cls, e):
        def f(e, results):
            if z3.is_const(e) and e.decl().kind() == z3.Z3_OP_UNINTERPRETED:
                results.append(e.decl())

        return set(cls.collect(e, f))


class DB(dict):
    @classmethod
    def load(cls, kmax_file):
        assert kmax_file.is_dir() or kmax_file.is_file(), kmax_file

        if kmax_file.is_dir():
            kmax_file = kmax_file / 'kmax'

        if not kmax_file.is_file():
            mlog.error("{} does not exist!".format(kmax_file))
            exit(1)

        with open(kmax_file, 'rb') as fp:
            kmax = pickle.load(fp)
            return kmax

    @classmethod
    def create_from_file(cls, kmax_file):
        d = cls.load(kmax_file)

        db = cls()
        for compile_unit in d:
            constraint = d[compile_unit]
            constraint = z3.parse_smt2_string(constraint)
            assert isinstance(constraint, z3.z3.AstVector), constraint
            assert len(constraint) <= 1, constraint
            if len(constraint) == 0:
                constraint = None
            else:
                assert len(constraint) == 1, constraint
                constraint = Z3.simplify(constraint[0])
            db[compile_unit] = constraint

        return db


class Analysis:
    def __init__(self, db):
        assert isinstance(db, DB), db
        self.db = db

    def get_constraint_forms(self):
        """
        Return the number of conj, disj, or mixed
        TODO: model counting?
        """
        for constraint in db.values():
            if constraint is not None:
                print(constraint)
                print(Z3.collect_connective_ops(constraint))
                print(Z3.collect_vars(constraint))


# def get_conditions(kmax_formulas, kbuild_path):
#     DBG()
#     if kbuild_path in kmax_formulas:
#         conditions = []
#         # add the condition for the compilation unit and each of its parent directories
#         unit_constraint = z3.parse_smt2_string(kmax_formulas[kbuild_path])
#         conditions.extend(unit_constraint)
#         mlog.debug("{} => {}".format(kbuild_path, unit_constraint))

#         if '/' in kbuild_path:
#             subpath, basename = kbuild_path.rsplit('/', 1)
#             elems = subpath.rsplit('/')
#             for i in range(0, len(elems)):
#                 subarray = elems[0:(len(elems) - i)]
#                 subsubpath = '/'.join(subarray) + "/"
#                 if subsubpath in kmax_formulas.keys():
#                     subsubpath_constraint = z3.parse_smt2_string(
#                         kmax_formulas[subsubpath])
#                     conditions.extend(subsubpath_constraint)
#                     mlog.debug("%s\n%s\n" %
#                                (subsubpath, subsubpath_constraint))
#                 else:
#                     mlog.info("%s has no kmax formula, assuming it is unconstrained." % (
#                         subsubpath))
#         return conditions
#     else:
#         return None


if __name__ == '__main__':
    argparser = argparse.ArgumentParser("KAnalysis")

    # 0 Error #1 Warn #2 Info #3 Debug #4 Detail
    ag = argparser.add_argument

    ag("inp", help="path to the directory or file containing kmax formula")

    ag("--log_level", "-log_level",
       type=int,
       choices=range(5),
       default=2,
       help="set logger info")

    # ag('--formulas',
    #    type=str,
    #    default=".kmax/",
    #    help="""Path to the formulas which contain one kmax file for all compilation units and one directory for each architecture containing kclause files.  Defaults to \".kmax/\"""")

    # ag('--kmax-formulas',
    #    type=str,
    #    default=None,
    #    help="""The file containing the Kbuild constraints as a pickled dictionary from compilation unit to formula.  Defaults to \"kmax\" in the --formulas directory.""")
    ag("--pathprefix",
       type=str,
       help="retrieve kmax formulas for this path prefix")
    args = argparser.parse_args()

    if 0 <= args.log_level <= 4 and args.log_level != settings.logger_level:
        settings.logger_level = args.log_level

    kmax_file = Path(args.inp)

    db = DB.create_from_file(kmax_file)
    analysis = Analysis(db)
    analysis.get_constraint_forms()

    # formulas = {unit: get_conditions(
    #     kmax_formulas, unit) for unit in kmax_formulas}
    # path_prefix = args.pathprefix
    # print(path_prefix)
    # filtered_formulas = {}
    # print(formulas)  # remove to avoid printing the whole map
